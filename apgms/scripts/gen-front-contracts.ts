import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.resolve(__dirname, "..");
const SCHEMA_DIR = path.join(ROOT, "services", "api-gateway", "src", "schemas");
const OUTPUT_DIR = path.join(ROOT, "webapp", "src", "contracts");
const SCHEMAS_OUTPUT = path.join(OUTPUT_DIR, "schemas.ts");
const TYPES_OUTPUT = path.join(OUTPUT_DIR, "types.ts");

const AUTO_HEADER = `// Auto-generated by scripts/gen-front-contracts.ts. Do not edit.\n`;

const indent = (value: string, depth = 1) =>
  value
    .split("\n")
    .map((line) => (line.length ? "  ".repeat(depth) + line : line))
    .join("\n");

type JSONSchema = {
  $ref?: string;
  $defs?: Record<string, JSONSchema>;
  definitions?: Record<string, JSONSchema>;
  type?: string | string[];
  enum?: Array<string | number | boolean | null>;
  const?: string | number | boolean | null | object;
  properties?: Record<string, JSONSchema>;
  required?: string[];
  additionalProperties?: boolean | JSONSchema;
  items?: JSONSchema | JSONSchema[];
  anyOf?: JSONSchema[];
  oneOf?: JSONSchema[];
  allOf?: JSONSchema[];
  description?: string;
  title?: string;
  nullable?: boolean;
  default?: unknown;
  minimum?: number;
  maximum?: number;
  exclusiveMinimum?: number;
  exclusiveMaximum?: number;
  minLength?: number;
  maxLength?: number;
  pattern?: string;
  minItems?: number;
  maxItems?: number;
  format?: string;
} & Record<string, unknown>;

type HelperSchema = {
  name: string;
  expression: string;
};

type GenerationContext = {
  root: JSONSchema;
  helpers: Map<string, HelperSchema>;
  helperOrder: HelperSchema[];
  resolvingRefs: Set<string>;
  definitions: Record<string, JSONSchema>;
  refCounts: Map<string, number>;
};

const toPascalCase = (value: string) =>
  value
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .split(" ")
    .filter(Boolean)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join("");

const makeIdentifier = (base: string, taken: Set<string>) => {
  let candidate = base.replace(/^[^a-zA-Z_$]+/, "");
  if (!candidate.length) {
    candidate = "Schema";
  }
  if (!taken.has(candidate)) {
    taken.add(candidate);
    return candidate;
  }
  let i = 2;
  while (taken.has(`${candidate}${i}`)) {
    i += 1;
  }
  const name = `${candidate}${i}`;
  taken.add(name);
  return name;
};

const resolvePointer = (schema: JSONSchema, pointer: string): JSONSchema => {
  if (!pointer.startsWith("#")) {
    throw new Error(`Only local $ref pointers are supported: ${pointer}`);
  }
  if (pointer === "#") {
    return schema;
  }
  const parts = pointer
    .slice(2)
    .split("/")
    .map((segment) => segment.replace(/~1/g, "/").replace(/~0/g, "~"));

  let current: any = schema;
  for (const part of parts) {
    if (current && typeof current === "object" && part in current) {
      current = current[part];
    } else {
      throw new Error(`Unable to resolve $ref: ${pointer}`);
    }
  }
  return current as JSONSchema;
};

const literalValue = (value: unknown) => {
  if (typeof value === "string") {
    return JSON.stringify(value);
  }
  if (typeof value === "number" || typeof value === "boolean") {
    return String(value);
  }
  if (value === null) {
    return "null";
  }
  return JSON.stringify(value);
};

const wrapWithNullable = (expression: string, nullable: boolean) =>
  nullable ? `${expression}.nullable()` : expression;

const wrapWithOptional = (expression: string, optional: boolean) =>
  optional ? `${expression}.optional()` : expression;

const applyDefault = (expression: string, schema: JSONSchema) => {
  if (!("default" in schema)) {
    return expression;
  }
  const defVal = (schema as { default: unknown }).default;
  return `${expression}.default(${literalValue(defVal)})`;
};

const withDescription = (expression: string, schema: JSONSchema) => {
  if (!schema.description) {
    return expression;
  }
  return `${expression}.describe(${JSON.stringify(schema.description)})`;
};

const applyStringConstraints = (expression: string, schema: JSONSchema) => {
  let current = expression;
  if (typeof schema.minLength === "number") {
    current += `.min(${schema.minLength})`;
  }
  if (typeof schema.maxLength === "number") {
    current += `.max(${schema.maxLength})`;
  }
  if (typeof schema.pattern === "string") {
    current += `.regex(new RegExp(${JSON.stringify(schema.pattern)}))`;
  }
  if (schema.format === "date-time") {
    current += `.datetime()`;
  }
  return current;
};

const applyNumberConstraints = (expression: string, schema: JSONSchema) => {
  let current = expression;
  if (typeof schema.minimum === "number") {
    current += `.min(${schema.minimum})`;
  }
  if (typeof schema.maximum === "number") {
    current += `.max(${schema.maximum})`;
  }
  if (typeof schema.exclusiveMinimum === "number") {
    current += `.gt(${schema.exclusiveMinimum})`;
  }
  if (typeof schema.exclusiveMaximum === "number") {
    current += `.lt(${schema.exclusiveMaximum})`;
  }
  return current;
};

const convert = (schema: JSONSchema, ctx: GenerationContext): string => {
  if (schema.$ref && typeof schema.$ref === "string") {
    const ref = schema.$ref;
    const helper = ctx.helpers.get(ref);
    const taken = new Set(Array.from(ctx.helpers.values()).map((entry) => entry.name));
    const name = helper?.name ?? makeIdentifier(toPascalCase(ref.split("/").pop() || "Ref") + "Schema", taken);
    if (ctx.resolvingRefs.has(ref)) {
      const resolvedName = helper?.name ?? name;
      return `z.lazy(() => ${resolvedName})`;
    }
    return ensureRef(ref, ctx);
  }

  if (Array.isArray(schema.enum) && schema.enum.length) {
    const enumValues = schema.enum;
    const stringEnum = enumValues.every((v) => typeof v === "string");
    if (stringEnum) {
      return `z.enum([${enumValues.map((v) => literalValue(v)).join(", ")}])`;
    }
    const literals = enumValues.map((v) => `z.literal(${literalValue(v)})`).join(", ");
    return `z.union([${literals}])`;
  }

  if ("const" in schema) {
    return `z.literal(${literalValue((schema as any).const)})`;
  }

  const handleCombined = (keyword: "anyOf" | "oneOf" | "allOf") => {
    const subschemas = (schema as any)[keyword] as JSONSchema[];
    if (!Array.isArray(subschemas) || !subschemas.length) {
      return undefined;
    }
    const converted = subschemas.map((sub) => convert(sub, ctx));
    if (keyword === "allOf") {
      return converted.reduce((acc, current) => `z.intersection(${acc}, ${current})`);
    }
    if (converted.length === 1) {
      return converted[0];
    }
    return `z.union([${converted.join(", ")}])`;
  };

  for (const key of ["anyOf", "oneOf", "allOf"] as const) {
    if (Array.isArray((schema as any)[key]) && (schema as any)[key].length) {
      return handleCombined(key)!;
    }
  }

  if (Array.isArray(schema.type)) {
    const converted = schema.type.map((t) => convert({ ...schema, type: t, nullable: false }, ctx));
    return `z.union([${converted.join(", ")}])`;
  }

  switch (schema.type) {
    case "object": {
      const props = schema.properties ?? {};
      const required = new Set(schema.required ?? []);
      const taken = new Set<string>();
      const entries = Object.entries(props).map(([key, value]) => {
        const convertedValue = convert(value as JSONSchema, ctx);
        const withNullability = wrapWithNullable(convertedValue, Boolean((value as JSONSchema).nullable));
        const finalValue = wrapWithOptional(
          applyDefault(withDescription(withNullability, value as JSONSchema), value as JSONSchema),
          !required.has(key)
        );
        return `${JSON.stringify(key)}: ${finalValue}`;
      });
      const objectBody = entries.length ? `\n${indent(entries.join(",\n"))}\n` : "";
      let objectExpr = `z.object({${objectBody}})`;
      if (schema.additionalProperties === false) {
        objectExpr += ".strict()";
      } else if (schema.additionalProperties && typeof schema.additionalProperties === "object") {
        const ap = convert(schema.additionalProperties as JSONSchema, ctx);
        objectExpr += `.catchall(${ap})`;
      }
      return applyDefault(withDescription(objectExpr, schema), schema);
    }
    case "array": {
      const items = schema.items;
      const itemExpr = Array.isArray(items)
        ? `z.tuple([${items.map((item) => convert(item, ctx)).join(", ")}])`
        : convert((items as JSONSchema) ?? {}, ctx);
      let arrayExpr = Array.isArray(items) ? itemExpr : `z.array(${itemExpr})`;
      if (typeof schema.minItems === "number") {
        arrayExpr += `.min(${schema.minItems})`;
      }
      if (typeof schema.maxItems === "number") {
        arrayExpr += `.max(${schema.maxItems})`;
      }
      return applyDefault(withDescription(arrayExpr, schema), schema);
    }
    case "string": {
      let strExpr = applyStringConstraints("z.string()", schema);
      strExpr = applyDefault(withDescription(strExpr, schema), schema);
      return wrapWithNullable(strExpr, Boolean(schema.nullable));
    }
    case "number": {
      let numExpr = applyNumberConstraints("z.number()", schema);
      numExpr = applyDefault(withDescription(numExpr, schema), schema);
      return wrapWithNullable(numExpr, Boolean(schema.nullable));
    }
    case "integer": {
      let intExpr = applyNumberConstraints("z.number().int()", schema);
      intExpr = applyDefault(withDescription(intExpr, schema), schema);
      return wrapWithNullable(intExpr, Boolean(schema.nullable));
    }
    case "boolean": {
      const boolExpr = applyDefault(withDescription("z.boolean()", schema), schema);
      return wrapWithNullable(boolExpr, Boolean(schema.nullable));
    }
    case "null": {
      return "z.null()";
    }
    default: {
      return "z.any()";
    }
  }
};

const ensureRef = (ref: string, ctx: GenerationContext) => {
  const existing = ctx.helpers.get(ref);
  if (existing?.expression) {
    return existing.name;
  }

  const pointer = ref.split("/").pop() || "Ref";
  const rawName = toPascalCase(pointer) || "Ref";
  const taken = new Set(Array.from(ctx.helpers.values()).map((helper) => helper.name));
  const name = makeIdentifier(`${rawName}Schema`, taken);
  const helper: HelperSchema = { name, expression: "" };
  ctx.helpers.set(ref, helper);

  ctx.resolvingRefs.add(ref);
  const target = resolvePointer(ctx.root, ref);
  const expression = convert(target, ctx);
  ctx.resolvingRefs.delete(ref);

  helper.expression = expression;
  ctx.helperOrder.push(helper);
  return helper.name;
};

const generateForSchema = (name: string, schema: JSONSchema) => {
  const ctx: GenerationContext = {
    root: schema,
    helpers: new Map(),
    helperOrder: [],
    resolvingRefs: new Set(),
    definitions: { ...(schema.$defs ?? {}), ...(schema.definitions ?? {}) },
    refCounts: new Map(),
  };

  const expression = convert(schema, ctx);
  const helperDecls = ctx.helperOrder
    .map((helper) => `const ${helper.name} = ${helper.expression};`)
    .join("\n\n");
  return { expression, helperDecls };
};

const main = async () => {
  let schemaEntries: string[] = [];
  try {
    schemaEntries = await fs.readdir(SCHEMA_DIR);
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === "ENOENT") {
      await fs.mkdir(SCHEMA_DIR, { recursive: true });
    } else {
      throw error;
    }
  }

  const schemaFiles = schemaEntries.filter((file) => file.endsWith(".schema.json"));
  const validators: { name: string; validatorName: string; expression: string; helpers: string; fallback?: boolean }[] = [];

  for (const file of schemaFiles) {
    const filepath = path.join(SCHEMA_DIR, file);
    const raw = await fs.readFile(filepath, "utf8");
    const schema = JSON.parse(raw) as JSONSchema;
    const baseName = toPascalCase(file.replace(/\.schema\.json$/i, ""));
    const validatorName = `${baseName}V`;
    const { expression, helperDecls } = generateForSchema(baseName, schema);
    validators.push({ name: baseName, validatorName, expression, helpers: helperDecls });
  }

  const FALLBACK_CONTRACTS = ["Policy", "Gate", "AllocationPreview", "Rpt", "Audit", "LedgerEntry"];
  const existingNames = new Set(validators.map((item) => item.name));
  for (const name of FALLBACK_CONTRACTS) {
    if (!existingNames.has(name)) {
      validators.push({
        name,
        validatorName: `${name}V`,
        expression: "z.any()",
        helpers: "",
        fallback: true,
      });
    }
  }

  validators.sort((a, b) => a.name.localeCompare(b.name));

  const schemaLines: string[] = [AUTO_HEADER, "import { z } from \"zod\";", ""];
  for (const validator of validators) {
    if (validator.helpers) {
      schemaLines.push(validator.helpers, "");
    }
    schemaLines.push(`export const ${validator.validatorName} = ${validator.expression};`, "");
  }
  if (validators.length === 0) {
    schemaLines.push("// No schemas found to generate validators.");
  }

  await fs.mkdir(OUTPUT_DIR, { recursive: true });
  await fs.writeFile(SCHEMAS_OUTPUT, `${schemaLines.join("\n")}\n`);

  const typeLines: string[] = [
    AUTO_HEADER,
    "import { z } from \"zod\";",
  ];
  if (validators.length) {
    typeLines.push(`import { ${validators.map((v) => v.validatorName).join(", ")} } from \"./schemas\";`, "");
    for (const validator of validators) {
      typeLines.push(`export type ${validator.name} = z.infer<typeof ${validator.validatorName}>;`);
    }
  } else {
    typeLines.push("// No validator types available.");
  }

  await fs.writeFile(TYPES_OUTPUT, `${typeLines.join("\n")}\n`);
};

void main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
