const DEFAULT_CONTENT_TYPE = "text/plain; version=0.0.4; charset=utf-8";

class MetricRegistry {
  constructor() {
    this._metrics = new Map();
  }

  registerMetric(metric) {
    if (this._metrics.has(metric.name)) {
      throw new Error(`Metric with name ${metric.name} already exists`);
    }
    this._metrics.set(metric.name, metric);
    return metric;
  }

  getSingleMetric(name) {
    return this._metrics.get(name);
  }

  metrics() {
    return Array.from(this._metrics.values())
      .map((metric) => metric.get())
      .filter(Boolean)
      .join("\n");
  }

  resetMetrics() {
    for (const metric of this._metrics.values()) {
      if (typeof metric.reset === "function") {
        metric.reset();
      }
    }
  }

  clear() {
    this._metrics.clear();
  }
}

function formatLabels(labels) {
  const entries = Object.entries(labels || {});
  if (entries.length === 0) {
    return "";
  }
  return `{${entries.map(([key, value]) => `${key}="${value}"`).join(",")}}`;
}

class Counter {
  constructor(config) {
    this.name = config.name;
    this.help = config.help;
    this.labelNames = config.labelNames || [];
    this.type = "counter";
    this._values = new Map();
    register.registerMetric(this);
  }

  inc(labelsOrValue, value) {
    let labels = {};
    let incValue = 1;
    if (typeof labelsOrValue === "number") {
      incValue = labelsOrValue;
    } else if (labelsOrValue && typeof labelsOrValue === "object") {
      labels = labelsOrValue;
    }
    if (typeof value === "number") {
      incValue = value;
    }
    const key = JSON.stringify(labels);
    const current = this._values.get(key) || 0;
    this._values.set(key, current + incValue);
  }

  reset() {
    this._values.clear();
  }

  get() {
    const header = `# HELP ${this.name} ${this.help}\n# TYPE ${this.name} counter`;
    const body = Array.from(this._values.entries())
      .map(([labels, value]) => {
        const parsedLabels = JSON.parse(labels);
        const labelSuffix = formatLabels(parsedLabels);
        return `${this.name}${labelSuffix} ${value}`;
      })
      .join("\n");
    return body ? `${header}\n${body}` : header;
  }
}

class Histogram {
  constructor(config) {
    this.name = config.name;
    this.help = config.help;
    this.labelNames = config.labelNames || [];
    this.buckets = Array.isArray(config.buckets)
      ? config.buckets.slice().sort((a, b) => a - b)
      : [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10];
    this.type = "histogram";
    this._values = new Map();
    register.registerMetric(this);
  }

  observe(labels, value) {
    if (typeof labels === "number") {
      value = labels;
      labels = {};
    }
    labels = labels || {};
    const key = JSON.stringify(labels);
    let buckets = this._values.get(key);
    if (!buckets) {
      buckets = {
        bucketCounts: new Array(this.buckets.length).fill(0),
        sum: 0,
        count: 0,
      };
      this._values.set(key, buckets);
    }
    for (let i = 0; i < this.buckets.length; i++) {
      if (value <= this.buckets[i]) {
        buckets.bucketCounts[i] += 1;
      }
    }
    buckets.sum += value;
    buckets.count += 1;
  }

  reset() {
    this._values.clear();
  }

  get() {
    const header = `# HELP ${this.name} ${this.help}\n# TYPE ${this.name} histogram`;
    const lines = [];
    for (const [labelsString, buckets] of this._values.entries()) {
      const labels = JSON.parse(labelsString);
      for (let i = 0; i < this.buckets.length; i++) {
        const bound = this.buckets[i];
        const leLabels = { ...labels, le: String(bound) };
        const labelSuffix = formatLabels(leLabels);
        lines.push(`${this.name}_bucket${labelSuffix} ${buckets.bucketCounts[i]}`);
      }
      const infLabels = { ...labels, le: "+Inf" };
      lines.push(`${this.name}_bucket${formatLabels(infLabels)} ${buckets.count}`);
      const labelSuffix = formatLabels(labels);
      lines.push(`${this.name}_sum${labelSuffix} ${buckets.sum}`);
      lines.push(`${this.name}_count${labelSuffix} ${buckets.count}`);
    }
    return lines.length > 0 ? `${header}\n${lines.join("\n")}` : header;
  }
}

const register = new MetricRegistry();
register.contentType = DEFAULT_CONTENT_TYPE;

let defaultsRegistered = false;

function collectDefaultMetrics() {
  if (defaultsRegistered) {
    return;
  }
  defaultsRegistered = true;
  const processStart = Date.now() / 1000;
  register.registerMetric({
    name: "process_cpu_user_seconds_total",
    help: "Total user CPU time spent in seconds.",
    type: "counter",
    get() {
      const usage = process.cpuUsage();
      const seconds = usage.user / 1e6;
      return (
        `# HELP process_cpu_user_seconds_total Total user CPU time spent in seconds.\n` +
        `# TYPE process_cpu_user_seconds_total counter\n` +
        `process_cpu_user_seconds_total ${seconds}`
      );
    },
    reset() {},
  });
  register.registerMetric({
    name: "process_start_time_seconds",
    help: "Start time of the process since unix epoch in seconds.",
    type: "gauge",
    get() {
      return (
        `# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n` +
        `# TYPE process_start_time_seconds gauge\n` +
        `process_start_time_seconds ${processStart}`
      );
    },
    reset() {},
  });
}

module.exports = {
  Counter,
  Histogram,
  collectDefaultMetrics,
  register,
};
